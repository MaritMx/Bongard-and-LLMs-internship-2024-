import cv2
import numpy as np
import os
import matplotlib.pyplot as plt

#### Try 1

# Load an extracted square image (replace with the path to one of your extracted images)
image_path = 'image_path_to_for_example p02_2_1_3'

# Load the image using OpenCV
image = cv2.imread(image_path)

# Create the sharpening kernel
kernel = np.array([[-1,-1,-1],
                 [-1,9,-1],
                [-1,-1,-1]])

# Other sharpening kernel
# kernel = np.array([[0, -1, 0],
                   [-1, 5, -1],
                   [0, -1, 0]])

# Sharpen the image using the custom kernel
sharpened_image = cv2.filter2D(image, -1, kernel)

# Save the sharpened image
cv2.imwrite('path_to_store_new_image', sharpened_image)


#### Try 2

# Base path where the original images are located
base_path = 'image_path_to_for_example p02_2_1_3'

# Path where the cleaned images will be saved
cleaned_images_path = 'path_to_store_new_image'

# Create the cleaned images directory if it doesn't exist
if not os.path.exists(cleaned_images_path):
    os.makedirs(cleaned_images_path)

# Loop through all files in the directory
for filename in os.listdir(base_path):
    # Check if the file matches the naming convention
    if filename.startswith("p01_") and filename.endswith(".png"):
        # Construct the full path of the image
        image_path = os.path.join(base_path, filename)
        
        # Read image as grayscale
        img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
        
        # Threshold to binary
        thresh = cv2.threshold(img, 1, 255, cv2.THRESH_BINARY)[1]
        
        # Apply morphology
        kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))
        morph = cv2.erode(thresh, kernel)
        morph = cv2.dilate(morph, kernel)
        
        # Find contours & draw only valid contour edges on a black image
        letter = np.zeros_like(img)
        cntrs, hier = cv2.findContours(morph, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
        for idx, c in enumerate(cntrs):
            area = cv2.contourArea(c)
            if area > 100:
                cv2.drawContours(letter, cntrs, idx, 255, 1, 8, hier)
        
        # Generate names for the output images based on the original filename
        base_name = filename[:-4]  # Remove the '.png' extension
        thresh_filename = f"{base_name}_thresh.png"
        morph_filename = f"{base_name}_morph.png"
        letter_filename = f"{base_name}_letter.png"
        
        # Write results to the cleaned images directory
        cv2.imwrite(os.path.join(cleaned_images_path, thresh_filename), thresh)
        cv2.imwrite(os.path.join(cleaned_images_path, morph_filename), morph)
        cv2.imwrite(os.path.join(cleaned_images_path, letter_filename), letter)


### Try 3

# Update the path to the image file
img_path = 'image_path_to_for_example p02_2_1_3'

# Read image as grayscale
img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)

# Threshold to binary
thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY)[1]

# Apply morphology
kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))
morph = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel)

# Find contours - write black over all small contours
letter = morph.copy()
cntrs = cv2.findContours(morph, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
cntrs = cntrs[0] if len(cntrs) == 2 else cntrs[1]
for c in cntrs:
    area = cv2.contourArea(c)
    if area < 100:
        cv2.drawContours(letter,[c],0,(0,0,0),-1)

# Do Canny edge detection
edges = cv2.Canny(letter, 200, 200)

# Save the processed image to the specified directory
save_path = 'path_to_store_new_image'
cv2.imwrite(save_path, edges)



#### Try 4

def auto_canny(image, sigma=0.33):
    # Compute the median of the single channel pixel intensities
    v = np.median(image)
    # Apply automatic Canny edge detection using the computed median
    lower = int(max(0, (1.0 - sigma) * v))
    upper = int(min(255, (1.0 + sigma) * v))
    edged = cv2.Canny(image, lower, upper)
    return edged

def main():
    # Update the path to your image
    img_path = 'image_path_to_for_example p02_2_1_3'
    img_1 = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)
    blurred = cv2.GaussianBlur(img_1, (3, 3), 0)
    auto_edge = auto_canny(blurred)
    
    # Invert the image colors
    inverted_image = cv2.bitwise_not(auto_edge)
    
    # Instead of displaying, save the output
    save_path = 'path_to_store_new_image'
    cv2.imwrite(save_path, inverted_image)
    
    # If you want to display the result uncomment the following lines:
    # plt.imshow(inverted_image, cmap='gray')
    # plt.show()

# Don't forget to call the main function!
if __name__ == "__main__":
    main()
